# Readable Code

![](https://www.oreilly.co.jp/books/images/picture_large978-4-87311-565-8.jpeg)

新人プログラマーが読むべき本に[リーダブルコード](https://www.amazon.co.jp/%E3%83%AA%E3%83%BC%E3%83%80%E3%83%96%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89-%E2%80%95%E3%82%88%E3%82%8A%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%9F%E3%82%81%E3%81%AE%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%A7%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%81%AA%E3%83%86%E3%82%AF%E3%83%8B%E3%83%83%E3%82%AF-Theory-practice-Boswell/dp/4873115655)があり、読みやすくわかりやすいコードを書くためにどうしたらいいかといったtipsが書いてある本である。

このページでは、本の内容を（剽窃にならない程度に）簡潔にまとめていこうと思う。

また、本書ではサンプルコードはCで書かれているが、pythonだったらどうなるか、ということにも重視してまとめたいと思う。

本書の章番号とホームページの章番号を一致させたいと思ったが、無理そうだ。



## 1章｜理解しやすいコード

### コードは他人が最短時間で理解できなければならない。

以下のコードは、`exponent`の符号により、戻り値を変えるpythonプログラムである。(mantissa = 仮数)

```python
return mantissa * exponent if exponent >= 0 else mantissa / exponent
```

```python
if (exponent >= 0):
    return mantissa * exponent
else:
    return mantissa / exponent
```

上のほうが短く記述できるが、下のほうが安心感がある。

### 短ければいいと言うわけではない。

コメントがあると長くはなるがわかりやすくなる。



## 2章｜名前に情報を詰め込む

### 明確な名前をつける

```python
# Bad
def GetPage(url):

# Good
def FetchPage(url):
def DownloadPage(url):
```

getのような単語は避ける。ローカルからなのかデータベースからなのかインターネットからなのかわからない。

Sizeも、**Height**か**Numnodes**か**MemoryBytes**とするとわかりやすい。

### 汎用的な名前は避ける。

tmpとかreturn_valみたいなものは良くない。

```python
# Bad
return_val = return_val + v[i] ** 2

# Good
sum_squares = sum_squares + v[i] ** 2 # 2乗の合計とわかる。
```

### tmpが悪いわけではない。

本当に一時的（しかも生存期間が短い）場合はいい。

他の関数に渡したり、何度も書き換えられたりするのは良くないという意味。

### イテレーターの場合。

`for i in members`のようなイテレータ（ループ変数）としてi, jなどを使う場合はこれでもいい。

しかし、`for i_member in members`や`for in im members`のほうがわかりやすい。

### 抽象的な名前より具体的な名前。

無理にまとめなくていい。直行する概念なら分ける。

### 名前に情報を追加する。

単位を追加する

```python
# Bad
start
height
dihedral

# Good
start_ps
height_au
dihedral_degree
```

### 注意喚起する。

`unsafeUrl`とか？あんま使わないかな。

### 名前の長さ。

長過ぎるのは避けるべきだが最近はエディタに補完機能がついている。

### 省略形と接頭語。

固有の省略でなければOK

```python
# Bad
CT # (Cytosine - Thymineを省略したつもり)

# Good
str_atom # (原子の文字)
rdf # (動径分布関数)
```

### 不必要な単語は捨てる。

情報が失われないならいい。

```python
# Bad
ConvertToString

# Good
ToString
```

### 名前のフォーマット。

```python
class CalcRdf:
    NUMSTEPS = 10000
    num_atom = []

```

クラス名はキャメルケース、定数は大文字、変数は小文字のアンダースコア区切り。

ローカル変数(val_)とグローバル変数(val)を区別するのも手。

```python
def SomeFunc(atom_):
    atom_ = ....

atom = SomeFunc(dmpc_atoms)
```



## 3章｜誤解されない名前をつける

### 他の名前と間違えられることはないか？

filterという単語は曖昧。**select**なのか**exclude**なのか

文字数はlength -> max_length -> max_charsがよい。

### 境界はmax, minでわかりやすく

**max**, **min**は境界を含む（以上以下）

### 範囲指定

**first**, **last**は含んでいることがわかりやすい（stopなどは避ける）。

**begin**, **end**が未満を示すイディオム（曖昧だが）。

### 期待に合わせる

getは軽量計算、時間がかかるものは**compute**にするとか

実験途中のidはtemplate, reuseではなく **inherit(継承、受け継ぐ)** という語句がある。ex) inherit_from_experiment



## 4章｜美しさ

読みやすい＝美しい

### 一貫性のある改行位置

一貫性をもたせ(謎の改行をしない)、コメントも揃える

```python
# Good
dmpc_atom_list = [dmpc,  #resname[str]
                  N1,    #atomname[str]
                  10000  #timesteps[int]
                 	]

chl1_atom_list = [chl1,  #resname[str]
                  OAB,   #atomname[str]
                  10000  #timesteps[int]
                 	]

# Very Good
# atomlist = (resname, atomname, timesteps)
#             [str]    [str]     [int]

dmpc_atom_list = [dmpc, N1,  10000]
chl1_atom_list = [chl1, OAB, 10000]
```

### 同じことが何度も出てくるならヘルパーメソッドを使う。

### 縦に揃える

インデントや空白を使う

```python
# Good
segments = MDAnalysis.select_atoms()
residues = MDAnalysis.select_atoms()
atoms    = MDAnalysi.select_atoms()
ids      = MDAnalysis.select_atoms()
```

こうすることで、3行目のtypoにも気づきやすい。

並びも一貫性のあるものにする。原子のあとに分子がきたらおかしいし一連のコードでは同じ並びを使うべきである。

### 宣言も意味のあるブロックにまとめる。



## 5章｜コメントすべきこと

コメントすべきでないこともある。

### <u>すぐ</u>わかることは書かない

```python
# Bad

# 動径分布関数の計算をする関数
def CalcRdf():
    # 結果を入れるリストの定義
    result = []
```

```python
# Good

# 標準入力からスペース区切りの数値をintにしてリストへ
num_atom = list(map(int, input().split()))
```

### 名前の酷さをコメントで補わない

なら名前を変える

**優れた名前 > ひどい名前 + 優れたコメント**の法則

### 自分の考えは記録する

```python
# Good

# append()を使うと遅かったのでstackを使った
# N1'原子は検索から漏れる
# 乱数発生ルーチンの最適化が必要
```

### バグも入れる

以下はよく使う略語

```python
# TODO : 後でやる
# FIXME: 既知の不具合
# HACK : きれいじゃない解決策
# XXX  : 危険な不具合

# Good

# TODO : Deal with other picture format like .png
```

### 定数にコメント

定数は生まれた背景があるはず。値を決めたときの考えを記載する。

```python
NUM_PROCESS = 2 # a node has 2 gpus.
```

### 質問されそうなことは書いておく+ハマりそうな罠も書いておく

ユーザーが気づく前に教えてあげる優しさ。

```python
# Good

# append()を使うと遅かったのでvstack()を使った
# map()の戻り値はリストではないためlist()が必要
```

### 全体像をコメントしろ

まとまりごとにコメントがあるといちいち関数内部を見なくていいため楽。



## 6章｜コメントは正確で完結に

### 短いコメント is good

### 曖昧な代名詞は良くない

それ、これなどはさける

### 歯切れのいい文章

〜かどうかで処理を変える　->　〜していなかったらxxする

### 関数の動作を正確に

行数をかぞえる　->　改行文字をかぞえる（個人的にはこの書き方はどうかと思うが）

"DMPC"の数をかぞえる　->　"DMPC"の文字を含む行数をカウント

### 実例を提示

ややこしい実例をみせるといい

### コードの意図

逆順にループ　->　原子番号の大きい方からループ

### 名前付き引数

```python
def Calc_Rg(residue_, timestep_):
    .......

# Bad
rg_dmpc = Calc_Rg("DMPC", u.coord.timesteps)

# Good
rg_dmpc = Calc_Rg(residue_ = "DMPC", timestep_ =  u.coord.timesteps)
```

pythonの機能であり、渡す引数を指定しながら渡せる。

C++やJavaでは使えないことに注意。（インラインコメントを使えばできるが。）

### 情報密度の高い言葉

dihedralのヒストグラムを総面積が1になるようにして返す　-> 規格化する。



## 7章｜制御フローを読みやすくする

### 条件式

`if length >= 10:` or `if 10 <= length:`

前者のほうが読みやすいのは、

- 左辺：調査対象であり、変化しやすい
- 右辺：比較対象であり、変化しにくい

からである。

日本語でも、「もし長さが10より大きければ」は自然だが「もし10より長さが大きければ」は伝わりにくい。

### if / elseブロック

なるべく条件式に否定形を使わない ex) `if length != length_dna:`

単純な条件から先に書く。

否定の条件であっても注意を引きつけるなら先に書く。

```python
# Good
if atoms not in residue:
    # print error log
else:
    # Do calculation
```

### 三項演算子

単純な場合はOK

```python
calc_status = "OK" if timesteps_fs > 0 else "NG"
```

これは、timesteps_fsの符号によってcalc_statusの文字が変わることがわかるが、冒頭の様に

```python
return mantissa * exponent if exponent >= 0 else mantissa / exponent
```

とかはわかりにくいと思う。単純に2つの値から1つを選ぶ時だけにする。

### do / whileはやめる

pythonにはdo{処理}while{条件}はない。(Perlなどはある。)無理やり書くならこんな感じ？

```python
# Bad
while True: # 無限ループ
    print("do infty!")
    if timestep_fs == 10000:
        break
```

この書き方は、ループの条件が上部に来ない(whileを読んだだけだとわからない)のでよくない。

### 関数から早く返す

意味がわからない。`try…except`や`with`を使えってこと？

### `goto`を使わない。

pythonにはない

### ネストは浅く

早めにif文から抜ける(`continue`の利用)

### 実行の流れを終えるか考える



## 8章｜巨大な式を分割する

### 説明変数の利用

式を表す変数（説明変数）の利用

```python
# Bad
if line.split()[0].strip() == "coordinate"

# Good
setting_keyword = line.split()[0].strip()
if setting_keyword = "coordinate"
```

### 要約変数の利用

```python
# Bad
if u.select_atoms("resname DNA and namd P") == u.select_atoms("resname RNA and namd P"):
    ....

# Good
atom_match = u.select_atoms("resname DNA and namd P") == u.select_atoms("resname RNA and namd P")
if atom_match:
    ....
```

原子が一致していたら〜するというのがわかりやすくなる。

### ドモルガンの法則

論理式はド・モルガンの法則が使える。（そんな複雑な条件式あるか？）

### 短絡評価

かしこい書き方は後でわかりにくくなるぞ

### 複雑なロジック

重なっているものは、重ならないものから考えたほうが楽なときもある。（余事象）

### 巨大な式の分割

### （C++）マクロの利用



## 9章｜変数と読みやすさ

### 役に立たない一時変数の削除

```python
# Bad
now = datatime.datatime.now()
time_ps = now

# Good
time_ps = datatime.datatime.now()
```



### 中間結果も捨てる

### 制御フロー変数はいらない

### 変数のスコープを縮める

やたらめったらグローバル変数にしてもしゃーない

深いネストで変数定義しない（変数定義は左端をあわせる）

全部上の方で定義しろって意味ではない。

### 変数は1度だけ代入する

定数をうまくつかって！



## 10章｜無関係の下位問題を抽出する

### 基本的な例

例えば、動径分布関数を計算するプログラムは

```python
def Calc_Rdf():
    for ts_ in timesteps_:
        # 原子の位置を取得
        # 原子間の距離を求める
    # 距離のヒストグラムを作成
    # 正規化
    # plotのためのデータを作成
    # アウトプットファイルを出力
```

おおよそ、こんな感じで計算がされるだろう。

しかし、原子間距離を求める部分や距離のヒストグラムを求める部分は別の関数にしたほうがわかりやすいだろう。

**特に、コード量が多い（自己完結している）部分は別関数にすると良い。**

再利用でき、個別にテストできるからだ。

### ユーティリティコード

c++にはファイルの中身をすべて読み込む関数がない。pythonはいろいろ用意されているのであんまりないかな。

### その他汎用コード

きれいに`print`する（中央揃えするなど）というコードは、別関数にしておくといい。後でデバッグする時に、ここだけ変えればいいから。

このような汎用コードは、簡単に共有できるような特別なディレクトリにまとめておくといい。(`util/`)

### プロジェクトに特化した機能

`dmpc = u.select_atoms("resname {} and name {}".format("dmpc", "P"))`などはいいが、コード量が多いときは関数化する。

（原子選択、タイムステップ全体の位置をnp.arrayにするなど）

### 既存のインターフェースを簡潔にする

### 必要に応じてインターフェースを整える

### やりすぎに注意

2〜3行のコードに分解すると逆にわかりづらくなるよ。



## 11章｜一度に1つのことを

コードは一つずつタスクを行うべきだ

### デフォルト値

pythonの関数にはデフォルト値を設定できる。これを利用して値があったら書き換えるなどする。

if文が連続すると様々な場合を見る必要があるため、大変



## 12章｜コードに思いを込める

### ロジックを明確に説明

### ライブラリを詳しく知る

### 解決策を口に出しながらコーディング



## 13章｜短いコードを書く

### いらない機能に悩まされない

### 質問と要求の分割

### 小さいコードを保つ

### 身近なライブラリに親しむ

pythonでは、`enumerate`関数を使えば、`for`文がとてもシンプルになる。

```python
names = ['Mirai','Tech','Denshi']

# Bad
index = 0
for name in names:
    print(index,name)
    index += 1

# Good
for index, name in enumerate(names,start=1):
    print(index, name)
```

また、リスト（タプル）から重複を取り除く`set`があるし、

リストの中でのインデックスを取得する`index()`メソッドがある。

```python
atom_list = ["N1", "P1", "O1", "O2"]

# Bad
for atom_i, _ in enumerate(atom_list):
    if atom_i = "O1":
        print(atom_i)

# Good
print(atom_list.index("O1"))
```

